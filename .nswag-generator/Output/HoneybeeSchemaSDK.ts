//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming



export class _OpenAPIGenBaseModel implements I_OpenAPIGenBaseModel {

    [key: string]: any;

    protected _discriminator: string;

    constructor(data?: I_OpenAPIGenBaseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "_OpenAPIGenBaseModel";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): _OpenAPIGenBaseModel {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "Autocalculate") {
            let result = new Autocalculate();
            result.init(data);
            return result;
        }
        if (data["type"] === "Location") {
            let result = new Location();
            result.init(data);
            return result;
        }
        if (data["type"] === "ProjectInfo") {
            let result = new ProjectInfo();
            result.init(data);
            return result;
        }
        let result = new _OpenAPIGenBaseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this._discriminator;
        return data;
    }
}

export interface I_OpenAPIGenBaseModel {

    [key: string]: any;
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export class Autocalculate extends _OpenAPIGenBaseModel implements IAutocalculate {
    readonly type: string = "Autocalculate";

    constructor(data?: IAutocalculate) {
        super(data);
        if (!data) {
            this.type = "Autocalculate";
        }
        this._discriminator = "Autocalculate";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Autocalculate";
        }
    }

    static override fromJS(data: any): Autocalculate {
        data = typeof data === 'object' ? data : {};
        let result = new Autocalculate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

/** Base class for all objects that are not extensible with additional keys. This effectively includes all objects except for the Properties classes that are assigned to geometry objects. */
export interface IAutocalculate extends I_OpenAPIGenBaseModel {
    type?: string;
}

/** A Ladybug Location. */
export class Location extends _OpenAPIGenBaseModel implements ILocation {
    readonly type: string = "Location";
    /** Name of the city as a string. */
    city?: string;
    /** Location latitude between -90 and 90 (Default: 0). */
    latitude?: number;
    /** Location longitude between -180 (west) and 180 (east) (Default: 0). */
    longitude?: number;
    /** Time zone between -12 hours (west) and +14 hours (east). If None, the time zone will be an estimated integer value derived from the longitude in accordance with solar time. */
    time_zone?: Autocalculate | number;
    /** A number for elevation of the location in meters. (Default: 0). */
    elevation?: number;
    /** ID of the location if the location is representing a weather station. */
    station_id?: string;
    /** Source of data (e.g. TMY, TMY3). */
    source?: string;

    [key: string]: any;

    constructor(data?: ILocation) {
        super(data);
        if (!data) {
            this.type = "Location";
            this.city = "-";
            this.latitude = 0;
            this.longitude = 0;
            this.elevation = 0;
        }
        this._discriminator = "Location";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "Location";
            this.city = _data["city"] !== undefined ? _data["city"] : "-";
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : 0;
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : 0;
            this.time_zone = _data["time_zone"];
            this.elevation = _data["elevation"] !== undefined ? _data["elevation"] : 0;
            this.station_id = _data["station_id"];
            this.source = _data["source"];
        }
    }

    static override fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["city"] = this.city;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["time_zone"] = this.time_zone;
        data["elevation"] = this.elevation;
        data["station_id"] = this.station_id;
        data["source"] = this.source;
        super.toJSON(data);
        return data;
    }
}

/** A Ladybug Location. */
export interface ILocation extends I_OpenAPIGenBaseModel {
    type?: string;
    /** Name of the city as a string. */
    city?: string;
    /** Location latitude between -90 and 90 (Default: 0). */
    latitude?: number;
    /** Location longitude between -180 (west) and 180 (east) (Default: 0). */
    longitude?: number;
    /** Time zone between -12 hours (west) and +14 hours (east). If None, the time zone will be an estimated integer value derived from the longitude in accordance with solar time. */
    time_zone?: Autocalculate | number;
    /** A number for elevation of the location in meters. (Default: 0). */
    elevation?: number;
    /** ID of the location if the location is representing a weather station. */
    station_id?: string;
    /** Source of data (e.g. TMY, TMY3). */
    source?: string;

    [key: string]: any;
}

/** An enumeration. */
export enum ClimateZones {
    _0A = "0A",
    _1A = "1A",
    _2A = "2A",
    _3A = "3A",
    _4A = "4A",
    _5A = "5A",
    _6A = "6A",
    _0B = "0B",
    _1B = "1B",
    _2B = "2B",
    _3B = "3B",
    _4B = "4B",
    _5B = "5B",
    _6B = "6B",
    _3C = "3C",
    _4C = "4C",
    _5C = "5C",
    _7 = "7",
    _8 = "8",
}

/** An enumeration. */
export enum BuildingTypes {
    Residential = "Residential",
    NonResidential = "NonResidential",
    MidriseApartment = "MidriseApartment",
    HighriseApartment = "HighriseApartment",
    LargeOffice = "LargeOffice",
    MediumOffice = "MediumOffice",
    SmallOffice = "SmallOffice",
    Retail = "Retail",
    StripMall = "StripMall",
    PrimarySchool = "PrimarySchool",
    SecondarySchool = "SecondarySchool",
    SmallHotel = "SmallHotel",
    LargeHotel = "LargeHotel",
    Hospital = "Hospital",
    Outpatient = "Outpatient",
    Warehouse = "Warehouse",
    SuperMarket = "SuperMarket",
    FullServiceRestaurant = "FullServiceRestaurant",
    QuickServiceRestaurant = "QuickServiceRestaurant",
    Laboratory = "Laboratory",
    Courthouse = "Courthouse",
}

/** An enumeration. */
export enum EfficiencyStandards {
    ASHRAE_2019 = "ASHRAE_2019",
    ASHRAE_2016 = "ASHRAE_2016",
    ASHRAE_2013 = "ASHRAE_2013",
    ASHRAE_2010 = "ASHRAE_2010",
    ASHRAE_2007 = "ASHRAE_2007",
    ASHRAE_2004 = "ASHRAE_2004",
    DOE_Ref_1980_2004 = "DOE_Ref_1980_2004",
    DOE_Ref_Pre_1980 = "DOE_Ref_Pre_1980",
}

/** Project information. */
export class ProjectInfo extends _OpenAPIGenBaseModel implements IProjectInfo {
    readonly type: string = "ProjectInfo";
    /** A number between -360 to 360 where positive values rotate the compass counterclockwise (towards the West) and negative values rotate the compass clockwise (towards the East). */
    north?: number;
    /** A list of URLs to zip files that includes EPW, DDY and STAT files. You can find these URLs from the EPWMAP. The first URL will be used as the primary weather file. */
    weather_urls?: string[];
    /** Project location. This value is usually generated from the information in the weather files. */
    location?: Location;
    /** Project location climate zone. */
    ashrae_climate_zone?: ClimateZones;
    /** A list of building types for the project. The first building type is considered the primary type for the project. */
    building_type?: BuildingTypes[];
    /** A list of building vintages (e.g. ASHRAE_2019, ASHRAE_2016). */
    vintage?: EfficiencyStandards[];

    [key: string]: any;

    constructor(data?: IProjectInfo) {
        super(data);
        if (!data) {
            this.type = "ProjectInfo";
            this.north = 0;
        }
        this._discriminator = "ProjectInfo";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ProjectInfo";
            this.north = _data["north"] !== undefined ? _data["north"] : 0;
            if (Array.isArray(_data["weather_urls"])) {
                this.weather_urls = [] as any;
                for (let item of _data["weather_urls"])
                    this.weather_urls!.push(item);
            }
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.ashrae_climate_zone = _data["ashrae_climate_zone"];
            if (Array.isArray(_data["building_type"])) {
                this.building_type = [] as any;
                for (let item of _data["building_type"])
                    this.building_type!.push(item);
            }
            if (Array.isArray(_data["vintage"])) {
                this.vintage = [] as any;
                for (let item of _data["vintage"])
                    this.vintage!.push(item);
            }
        }
    }

    static override fromJS(data: any): ProjectInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectInfo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["north"] = this.north;
        if (Array.isArray(this.weather_urls)) {
            data["weather_urls"] = [];
            for (let item of this.weather_urls)
                data["weather_urls"].push(item);
        }
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["ashrae_climate_zone"] = this.ashrae_climate_zone;
        if (Array.isArray(this.building_type)) {
            data["building_type"] = [];
            for (let item of this.building_type)
                data["building_type"].push(item);
        }
        if (Array.isArray(this.vintage)) {
            data["vintage"] = [];
            for (let item of this.vintage)
                data["vintage"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Project information. */
export interface IProjectInfo extends I_OpenAPIGenBaseModel {
    type?: string;
    /** A number between -360 to 360 where positive values rotate the compass counterclockwise (towards the West) and negative values rotate the compass clockwise (towards the East). */
    north?: number;
    /** A list of URLs to zip files that includes EPW, DDY and STAT files. You can find these URLs from the EPWMAP. The first URL will be used as the primary weather file. */
    weather_urls?: string[];
    /** Project location. This value is usually generated from the information in the weather files. */
    location?: Location;
    /** Project location climate zone. */
    ashrae_climate_zone?: ClimateZones;
    /** A list of building types for the project. The first building type is considered the primary type for the project. */
    building_type?: BuildingTypes[];
    /** A list of building vintages (e.g. ASHRAE_2019, ASHRAE_2016). */
    vintage?: EfficiencyStandards[];

    [key: string]: any;
}

