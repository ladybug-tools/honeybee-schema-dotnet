/* 
 * Honeybee Model Schema
 *
 * Documentation for Honeybee model schema
 *
 * Contact: info@ladybug.tools
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

extern alias LBTNewtonSoft;
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using LBTNewtonSoft::Newtonsoft.Json;
using LBTNewtonSoft::Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;


namespace HoneybeeSchema
{
    /// <summary>
    /// Radiance BSDF (Bidirectional Scattering Distribution Function) material.
    /// </summary>
    [Summary(@"Radiance BSDF (Bidirectional Scattering Distribution Function) material.")]
    [Serializable]
    [DataContract(Name = "BSDF")]
    public partial class BSDF : ModifierBase, IEquatable<BSDF>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BSDF" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected BSDF() 
        { 
            // Set non-required readonly properties with defaultValue
            this.Type = "BSDF";
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="BSDF" /> class.
        /// </summary>
        /// <param name="bsdfData">A string with the contents of the BSDF XML file. (required).</param>
        /// <param name="modifier">Material modifier..</param>
        /// <param name="dependencies">List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers..</param>
        /// <param name="upOrientation">Vector as sequence that sets the hemisphere that the BSDF material faces..</param>
        /// <param name="thickness">Optional number to set the thickness of the BSDF material Sign of thickness indicates whether proxied geometry is behind the BSDF surface (when thickness is positive) or in front (when thickness is negative). (default to 0D).</param>
        /// <param name="functionFile">Optional input for function file. Using \&quot;.\&quot; will ensure that BSDF data is written to the root of wherever a given study is run. (default to &quot;.&quot;).</param>
        /// <param name="transform">Optional transform input to scale the thickness and reorient the up vector..</param>
        /// <param name="frontDiffuseReflectance">Optional additional front diffuse reflectance as sequence of three RGB numbers..</param>
        /// <param name="backDiffuseReflectance">Optional additional back diffuse reflectance as sequence of three RGB numbers..</param>
        /// <param name="diffuseTransmittance">Optional additional diffuse transmittance as sequence of three RGB numbers..</param>
        /// <param name="identifier">Text string for a unique Radiance object. Must not contain spaces or special characters. This will be used to identify the object across a model and in the exported Radiance files. (required).</param>
        /// <param name="displayName">Display name of the object with no character restrictions..</param>
        public BSDF
        (
            string identifier, string bsdfData, // Required parameters
            string displayName= default, AnyOf<Plastic, Glass, BSDF, Glow, Light, Trans, Metal, Void, Mirror> modifier= default, List<AnyOf<Plastic, Glass, BSDF, Glow, Light, Trans, Metal, Void, Mirror>> dependencies= default, List<double> upOrientation= default, double thickness = 0D, string functionFile = ".", string transform= default, List<double> frontDiffuseReflectance= default, List<double> backDiffuseReflectance= default, List<double> diffuseTransmittance= default // Optional parameters
        ) : base(identifier: identifier, displayName: displayName )// BaseClass
        {
            // to ensure "bsdfData" is required (not null)
            this.BsdfData = bsdfData ?? throw new ArgumentNullException("bsdfData is a required property for BSDF and cannot be null");
            this.Modifier = modifier;
            this.Dependencies = dependencies;
            this.UpOrientation = upOrientation;
            this.Thickness = thickness;
            // use default value if no "functionFile" provided
            this.FunctionFile = functionFile ?? ".";
            this.Transform = transform;
            this.FrontDiffuseReflectance = frontDiffuseReflectance;
            this.BackDiffuseReflectance = backDiffuseReflectance;
            this.DiffuseTransmittance = diffuseTransmittance;

            // Set non-required readonly properties with defaultValue
            this.Type = "BSDF";

            // check if object is valid, only check for inherited class
            if (this.GetType() == typeof(BSDF))
                this.IsValid(throwException: true);
        }

        //============================================== is ReadOnly 
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [Summary(@"Type")]
        [DataMember(Name = "type")]
        public override string Type { get; protected set; }  = "BSDF";

        /// <summary>
        /// A string with the contents of the BSDF XML file.
        /// </summary>
        /// <value>A string with the contents of the BSDF XML file.</value>
        [Summary(@"A string with the contents of the BSDF XML file.")]
        [DataMember(Name = "bsdf_data", IsRequired = true)]
        public string BsdfData { get; set; } 
        /// <summary>
        /// Material modifier.
        /// </summary>
        /// <value>Material modifier.</value>
        [Summary(@"Material modifier.")]
        [DataMember(Name = "modifier")]
        public AnyOf<Plastic, Glass, BSDF, Glow, Light, Trans, Metal, Void, Mirror> Modifier { get; set; } 
        /// <summary>
        /// List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers.
        /// </summary>
        /// <value>List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers.</value>
        [Summary(@"List of modifiers that this modifier depends on. This argument is only useful for defining advanced modifiers where the modifier is defined based on other modifiers.")]
        [DataMember(Name = "dependencies")]
        public List<AnyOf<Plastic, Glass, BSDF, Glow, Light, Trans, Metal, Void, Mirror>> Dependencies { get; set; } 
        /// <summary>
        /// Vector as sequence that sets the hemisphere that the BSDF material faces.
        /// </summary>
        /// <value>Vector as sequence that sets the hemisphere that the BSDF material faces.</value>
        [Summary(@"Vector as sequence that sets the hemisphere that the BSDF material faces.")]
        [DataMember(Name = "up_orientation")]
        public List<double> UpOrientation { get; set; } 
        /// <summary>
        /// Optional number to set the thickness of the BSDF material Sign of thickness indicates whether proxied geometry is behind the BSDF surface (when thickness is positive) or in front (when thickness is negative).
        /// </summary>
        /// <value>Optional number to set the thickness of the BSDF material Sign of thickness indicates whether proxied geometry is behind the BSDF surface (when thickness is positive) or in front (when thickness is negative).</value>
        [Summary(@"Optional number to set the thickness of the BSDF material Sign of thickness indicates whether proxied geometry is behind the BSDF surface (when thickness is positive) or in front (when thickness is negative).")]
        [DataMember(Name = "thickness")]
        public double Thickness { get; set; }  = 0D;
        /// <summary>
        /// Optional input for function file. Using \&quot;.\&quot; will ensure that BSDF data is written to the root of wherever a given study is run.
        /// </summary>
        /// <value>Optional input for function file. Using \&quot;.\&quot; will ensure that BSDF data is written to the root of wherever a given study is run.</value>
        [Summary(@"Optional input for function file. Using \&quot;.\&quot; will ensure that BSDF data is written to the root of wherever a given study is run.")]
        [DataMember(Name = "function_file")]
        public string FunctionFile { get; set; }  = ".";
        /// <summary>
        /// Optional transform input to scale the thickness and reorient the up vector.
        /// </summary>
        /// <value>Optional transform input to scale the thickness and reorient the up vector.</value>
        [Summary(@"Optional transform input to scale the thickness and reorient the up vector.")]
        [DataMember(Name = "transform")]
        public string Transform { get; set; } 
        /// <summary>
        /// Optional additional front diffuse reflectance as sequence of three RGB numbers.
        /// </summary>
        /// <value>Optional additional front diffuse reflectance as sequence of three RGB numbers.</value>
        [Summary(@"Optional additional front diffuse reflectance as sequence of three RGB numbers.")]
        [DataMember(Name = "front_diffuse_reflectance")]
        public List<double> FrontDiffuseReflectance { get; set; } 
        /// <summary>
        /// Optional additional back diffuse reflectance as sequence of three RGB numbers.
        /// </summary>
        /// <value>Optional additional back diffuse reflectance as sequence of three RGB numbers.</value>
        [Summary(@"Optional additional back diffuse reflectance as sequence of three RGB numbers.")]
        [DataMember(Name = "back_diffuse_reflectance")]
        public List<double> BackDiffuseReflectance { get; set; } 
        /// <summary>
        /// Optional additional diffuse transmittance as sequence of three RGB numbers.
        /// </summary>
        /// <value>Optional additional diffuse transmittance as sequence of three RGB numbers.</value>
        [Summary(@"Optional additional diffuse transmittance as sequence of three RGB numbers.")]
        [DataMember(Name = "diffuse_transmittance")]
        public List<double> DiffuseTransmittance { get; set; } 

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            return "BSDF";
        }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString(bool detailed)
        {
            if (!detailed)
                return this.ToString();
            
            var sb = new StringBuilder();
            sb.Append("BSDF:\n");
            sb.Append("  Type: ").Append(this.Type).Append("\n");
            sb.Append("  Identifier: ").Append(this.Identifier).Append("\n");
            sb.Append("  DisplayName: ").Append(this.DisplayName).Append("\n");
            sb.Append("  BsdfData: ").Append(this.BsdfData).Append("\n");
            sb.Append("  Modifier: ").Append(this.Modifier).Append("\n");
            sb.Append("  Dependencies: ").Append(this.Dependencies).Append("\n");
            sb.Append("  UpOrientation: ").Append(this.UpOrientation).Append("\n");
            sb.Append("  Thickness: ").Append(this.Thickness).Append("\n");
            sb.Append("  FunctionFile: ").Append(this.FunctionFile).Append("\n");
            sb.Append("  Transform: ").Append(this.Transform).Append("\n");
            sb.Append("  FrontDiffuseReflectance: ").Append(this.FrontDiffuseReflectance).Append("\n");
            sb.Append("  BackDiffuseReflectance: ").Append(this.BackDiffuseReflectance).Append("\n");
            sb.Append("  DiffuseTransmittance: ").Append(this.DiffuseTransmittance).Append("\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the object from JSON string
        /// </summary>
        /// <returns>BSDF object</returns>
        public static BSDF FromJson(string json)
        {
            var obj = JsonConvert.DeserializeObject<BSDF>(json, JsonSetting.AnyOfConvertSetting);
            if (obj == null)
                return null;
            return obj.Type.ToLower() == obj.GetType().Name.ToLower() && obj.IsValid(throwException: true) ? obj : null;
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>BSDF object</returns>
        public virtual BSDF DuplicateBSDF()
        {
            return FromJson(this.ToJson());
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel Duplicate()
        {
            return DuplicateBSDF();
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override ModifierBase DuplicateModifierBase()
        {
            return DuplicateBSDF();
        }
     
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            input = input is AnyOf anyOf ? anyOf.Obj : input;
            return this.Equals(input as BSDF);
        }

        /// <summary>
        /// Returns true if BSDF instances are equal
        /// </summary>
        /// <param name="input">Instance of BSDF to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(BSDF input)
        {
            if (input == null)
                return false;
            return base.Equals(input) && 
                    Extension.Equals(this.BsdfData, input.BsdfData) && 
                    Extension.Equals(this.Modifier, input.Modifier) && 
                (
                    this.Dependencies == input.Dependencies ||
                    Extension.AllEquals(this.Dependencies, input.Dependencies)
                ) && 
                (
                    this.UpOrientation == input.UpOrientation ||
                    Extension.AllEquals(this.UpOrientation, input.UpOrientation)
                ) && 
                    Extension.Equals(this.Thickness, input.Thickness) && 
                    Extension.Equals(this.FunctionFile, input.FunctionFile) && 
                    Extension.Equals(this.Transform, input.Transform) && 
                (
                    this.FrontDiffuseReflectance == input.FrontDiffuseReflectance ||
                    Extension.AllEquals(this.FrontDiffuseReflectance, input.FrontDiffuseReflectance)
                ) && 
                (
                    this.BackDiffuseReflectance == input.BackDiffuseReflectance ||
                    Extension.AllEquals(this.BackDiffuseReflectance, input.BackDiffuseReflectance)
                ) && 
                (
                    this.DiffuseTransmittance == input.DiffuseTransmittance ||
                    Extension.AllEquals(this.DiffuseTransmittance, input.DiffuseTransmittance)
                ) && 
                    Extension.Equals(this.Type, input.Type);
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.BsdfData != null)
                    hashCode = hashCode * 59 + this.BsdfData.GetHashCode();
                if (this.Modifier != null)
                    hashCode = hashCode * 59 + this.Modifier.GetHashCode();
                if (this.Dependencies != null)
                    hashCode = hashCode * 59 + this.Dependencies.GetHashCode();
                if (this.UpOrientation != null)
                    hashCode = hashCode * 59 + this.UpOrientation.GetHashCode();
                if (this.Thickness != null)
                    hashCode = hashCode * 59 + this.Thickness.GetHashCode();
                if (this.FunctionFile != null)
                    hashCode = hashCode * 59 + this.FunctionFile.GetHashCode();
                if (this.Transform != null)
                    hashCode = hashCode * 59 + this.Transform.GetHashCode();
                if (this.FrontDiffuseReflectance != null)
                    hashCode = hashCode * 59 + this.FrontDiffuseReflectance.GetHashCode();
                if (this.BackDiffuseReflectance != null)
                    hashCode = hashCode * 59 + this.BackDiffuseReflectance.GetHashCode();
                if (this.DiffuseTransmittance != null)
                    hashCode = hashCode * 59 + this.DiffuseTransmittance.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            foreach(var x in base.BaseValidate(validationContext)) yield return x;
            // FunctionFile (string) maxLength
            if(this.FunctionFile != null && this.FunctionFile.Length > 100)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FunctionFile, length must be less than 100.", new [] { "FunctionFile" });
            }

            // FunctionFile (string) minLength
            if(this.FunctionFile != null && this.FunctionFile.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FunctionFile, length must be greater than 1.", new [] { "FunctionFile" });
            }
            
            // Transform (string) maxLength
            if(this.Transform != null && this.Transform.Length > 100)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Transform, length must be less than 100.", new [] { "Transform" });
            }

            // Transform (string) minLength
            if(this.Transform != null && this.Transform.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Transform, length must be greater than 1.", new [] { "Transform" });
            }
            

            
            // Type (string) pattern
            Regex regexType = new Regex(@"^BSDF$", RegexOptions.CultureInvariant);
            if (this.Type != null && false == regexType.Match(this.Type).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Type, must match a pattern of " + regexType, new [] { "Type" });
            }

            yield break;
        }
    }
}
