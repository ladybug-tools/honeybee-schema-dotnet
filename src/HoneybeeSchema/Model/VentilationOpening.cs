/* 
 * Honeybee Model Schema
 *
 * Documentation for Honeybee model schema
 *
 * Contact: info@ladybug.tools
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;


namespace HoneybeeSchema
{
    /// <summary>
    /// Base class for all objects that are not extensible with additional keys.  This effectively includes all objects except for the Properties classes that are assigned to geometry objects.
    /// </summary>
    [DataContract(Name = "VentilationOpening")]
    [JsonConverter(typeof(JsonSubtypes), "Type")]
    public partial class VentilationOpening : OpenAPIGenBaseModel, IEquatable<VentilationOpening>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="VentilationOpening" /> class.
        /// </summary>
        /// <param name="fractionAreaOperable">A number for the fraction of the window area that is operable. (default to 0.5D).</param>
        /// <param name="fractionHeightOperable">A number for the fraction of the distance from the bottom of the window to the top that is operable (default to 1.0D).</param>
        /// <param name="dischargeCoefficient">A number that will be multipled by the area of the window in the stack (buoyancy-driven) part of the equation to account for additional friction from window geometry, insect screens, etc. Typical values include 0.45, for unobstructed windows WITH insect screens and 0.65 for unobstructed windows WITHOUT insect screens. This value should be lowered if windows are of an awning or casement type and are not allowed to fully open. (default to 0.45D).</param>
        /// <param name="windCrossVent">Boolean to indicate if there is an opening of roughly equal area on the opposite side of the Room such that wind-driven cross ventilation will be induced. If False, the assumption is that the operable area is primarily on one side of the Room and there is no wind-driven ventilation. (default to false).</param>
        /// <param name="flowCoefficientClosed">An optional number in kg/s-m, at 1 Pa per meter of crack length, used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. The DesignBuilder Cracks template defines the flow coefficient for a tight, low-leakage closed external window to be 0.00001, and the flow coefficient for a very poor, high-leakage closed external window to be 0.003..</param>
        /// <param name="flowExponentClosed">An optional dimensionless number between 0.5 and 1 used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. This value represents the leak geometry impact on airflow, with 0.5 generally corresponding to turbulent orifice flow and 1 generally corresponding to laminar flow. The default of 0.65 is representative of many cases of wall and window leakage, used when the exponent cannot be measured. (default to 0.65D).</param>
        /// <param name="twoWayThreshold">A number in kg/m3 indicating the minimum density difference above which two-way flow may occur due to stack effect, required to run an AirflowNetwork simulation. This value is required because the air density difference between two zones (which drives two-way air flow) will tend towards division by zero errors as the air density difference approaches zero. The default of 0.0001 is a typical default value used for AirflowNetwork openings. (default to 0.00010D).</param>
        public VentilationOpening
        (
             // Required parameters
            double fractionAreaOperable = 0.5D, double fractionHeightOperable = 1.0D, double dischargeCoefficient = 0.45D, bool windCrossVent = false, double flowCoefficientClosed= default, double flowExponentClosed = 0.65D, double twoWayThreshold = 0.00010D// Optional parameters
        ) : base()// BaseClass
        {
            this.FractionAreaOperable = fractionAreaOperable;
            this.FractionHeightOperable = fractionHeightOperable;
            this.DischargeCoefficient = dischargeCoefficient;
            this.WindCrossVent = windCrossVent;
            this.FlowCoefficientClosed = flowCoefficientClosed;
            this.FlowExponentClosed = flowExponentClosed;
            this.TwoWayThreshold = twoWayThreshold;

            // Set non-required readonly properties with defaultValue
            this.Type = "VentilationOpening";
        }

        /// <summary>
        /// A number for the fraction of the window area that is operable.
        /// </summary>
        /// <value>A number for the fraction of the window area that is operable.</value>
        [DataMember(Name="fraction_area_operable", EmitDefaultValue=false)]
        public double FractionAreaOperable { get; set; }  = 0.5D;
        /// <summary>
        /// A number for the fraction of the distance from the bottom of the window to the top that is operable
        /// </summary>
        /// <value>A number for the fraction of the distance from the bottom of the window to the top that is operable</value>
        [DataMember(Name="fraction_height_operable", EmitDefaultValue=false)]
        public double FractionHeightOperable { get; set; }  = 1.0D;
        /// <summary>
        /// A number that will be multipled by the area of the window in the stack (buoyancy-driven) part of the equation to account for additional friction from window geometry, insect screens, etc. Typical values include 0.45, for unobstructed windows WITH insect screens and 0.65 for unobstructed windows WITHOUT insect screens. This value should be lowered if windows are of an awning or casement type and are not allowed to fully open.
        /// </summary>
        /// <value>A number that will be multipled by the area of the window in the stack (buoyancy-driven) part of the equation to account for additional friction from window geometry, insect screens, etc. Typical values include 0.45, for unobstructed windows WITH insect screens and 0.65 for unobstructed windows WITHOUT insect screens. This value should be lowered if windows are of an awning or casement type and are not allowed to fully open.</value>
        [DataMember(Name="discharge_coefficient", EmitDefaultValue=false)]
        public double DischargeCoefficient { get; set; }  = 0.45D;
        /// <summary>
        /// Boolean to indicate if there is an opening of roughly equal area on the opposite side of the Room such that wind-driven cross ventilation will be induced. If False, the assumption is that the operable area is primarily on one side of the Room and there is no wind-driven ventilation.
        /// </summary>
        /// <value>Boolean to indicate if there is an opening of roughly equal area on the opposite side of the Room such that wind-driven cross ventilation will be induced. If False, the assumption is that the operable area is primarily on one side of the Room and there is no wind-driven ventilation.</value>
        [DataMember(Name="wind_cross_vent", EmitDefaultValue=false)]
        public bool WindCrossVent { get; set; }  = false;
        /// <summary>
        /// An optional number in kg/s-m, at 1 Pa per meter of crack length, used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. The DesignBuilder Cracks template defines the flow coefficient for a tight, low-leakage closed external window to be 0.00001, and the flow coefficient for a very poor, high-leakage closed external window to be 0.003.
        /// </summary>
        /// <value>An optional number in kg/s-m, at 1 Pa per meter of crack length, used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. The DesignBuilder Cracks template defines the flow coefficient for a tight, low-leakage closed external window to be 0.00001, and the flow coefficient for a very poor, high-leakage closed external window to be 0.003.</value>
        [DataMember(Name="flow_coefficient_closed", EmitDefaultValue=false)]
        public double FlowCoefficientClosed { get; set; } 
        /// <summary>
        /// An optional dimensionless number between 0.5 and 1 used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. This value represents the leak geometry impact on airflow, with 0.5 generally corresponding to turbulent orifice flow and 1 generally corresponding to laminar flow. The default of 0.65 is representative of many cases of wall and window leakage, used when the exponent cannot be measured.
        /// </summary>
        /// <value>An optional dimensionless number between 0.5 and 1 used to calculate the mass flow rate when the opening is closed; required to run an AirflowNetwork simulation. This value represents the leak geometry impact on airflow, with 0.5 generally corresponding to turbulent orifice flow and 1 generally corresponding to laminar flow. The default of 0.65 is representative of many cases of wall and window leakage, used when the exponent cannot be measured.</value>
        [DataMember(Name="flow_exponent_closed", EmitDefaultValue=false)]
        public double FlowExponentClosed { get; set; }  = 0.65D;
        /// <summary>
        /// A number in kg/m3 indicating the minimum density difference above which two-way flow may occur due to stack effect, required to run an AirflowNetwork simulation. This value is required because the air density difference between two zones (which drives two-way air flow) will tend towards division by zero errors as the air density difference approaches zero. The default of 0.0001 is a typical default value used for AirflowNetwork openings.
        /// </summary>
        /// <value>A number in kg/m3 indicating the minimum density difference above which two-way flow may occur due to stack effect, required to run an AirflowNetwork simulation. This value is required because the air density difference between two zones (which drives two-way air flow) will tend towards division by zero errors as the air density difference approaches zero. The default of 0.0001 is a typical default value used for AirflowNetwork openings.</value>
        [DataMember(Name="two_way_threshold", EmitDefaultValue=false)]
        public double TwoWayThreshold { get; set; }  = 0.00010D;

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            if (this is IIDdBase iDd)
                return $"VentilationOpening {iDd.Identifier}";
       
            return "VentilationOpening";
        }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString(bool detailed)
        {
            if (!detailed)
                return this.ToString();
            
            var sb = new StringBuilder();
            sb.Append("VentilationOpening:\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  FractionAreaOperable: ").Append(FractionAreaOperable).Append("\n");
            sb.Append("  FractionHeightOperable: ").Append(FractionHeightOperable).Append("\n");
            sb.Append("  DischargeCoefficient: ").Append(DischargeCoefficient).Append("\n");
            sb.Append("  WindCrossVent: ").Append(WindCrossVent).Append("\n");
            sb.Append("  FlowCoefficientClosed: ").Append(FlowCoefficientClosed).Append("\n");
            sb.Append("  FlowExponentClosed: ").Append(FlowExponentClosed).Append("\n");
            sb.Append("  TwoWayThreshold: ").Append(TwoWayThreshold).Append("\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the object from JSON string
        /// </summary>
        /// <returns>VentilationOpening object</returns>
        public static VentilationOpening FromJson(string json)
        {
            var obj = JsonConvert.DeserializeObject<VentilationOpening>(json, JsonSetting.AnyOfConvertSetting);
            if (obj == null)
                return null;
            return obj.Type.ToLower() == obj.GetType().Name.ToLower() ? obj : null;
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>VentilationOpening object</returns>
        public VentilationOpening DuplicateVentilationOpening()
        {
            return FromJson(this.ToJson()) as VentilationOpening;
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel Duplicate()
        {
            return FromJson(this.ToJson());
        }
     
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as VentilationOpening);
        }

        /// <summary>
        /// Returns true if VentilationOpening instances are equal
        /// </summary>
        /// <param name="input">Instance of VentilationOpening to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(VentilationOpening input)
        {
            if (input == null)
                return false;
            return base.Equals(input) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && base.Equals(input) && 
                (
                    this.FractionAreaOperable == input.FractionAreaOperable ||
                    (this.FractionAreaOperable != null &&
                    this.FractionAreaOperable.Equals(input.FractionAreaOperable))
                ) && base.Equals(input) && 
                (
                    this.FractionHeightOperable == input.FractionHeightOperable ||
                    (this.FractionHeightOperable != null &&
                    this.FractionHeightOperable.Equals(input.FractionHeightOperable))
                ) && base.Equals(input) && 
                (
                    this.DischargeCoefficient == input.DischargeCoefficient ||
                    (this.DischargeCoefficient != null &&
                    this.DischargeCoefficient.Equals(input.DischargeCoefficient))
                ) && base.Equals(input) && 
                (
                    this.WindCrossVent == input.WindCrossVent ||
                    (this.WindCrossVent != null &&
                    this.WindCrossVent.Equals(input.WindCrossVent))
                ) && base.Equals(input) && 
                (
                    this.FlowCoefficientClosed == input.FlowCoefficientClosed ||
                    (this.FlowCoefficientClosed != null &&
                    this.FlowCoefficientClosed.Equals(input.FlowCoefficientClosed))
                ) && base.Equals(input) && 
                (
                    this.FlowExponentClosed == input.FlowExponentClosed ||
                    (this.FlowExponentClosed != null &&
                    this.FlowExponentClosed.Equals(input.FlowExponentClosed))
                ) && base.Equals(input) && 
                (
                    this.TwoWayThreshold == input.TwoWayThreshold ||
                    (this.TwoWayThreshold != null &&
                    this.TwoWayThreshold.Equals(input.TwoWayThreshold))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.FractionAreaOperable != null)
                    hashCode = hashCode * 59 + this.FractionAreaOperable.GetHashCode();
                if (this.FractionHeightOperable != null)
                    hashCode = hashCode * 59 + this.FractionHeightOperable.GetHashCode();
                if (this.DischargeCoefficient != null)
                    hashCode = hashCode * 59 + this.DischargeCoefficient.GetHashCode();
                if (this.WindCrossVent != null)
                    hashCode = hashCode * 59 + this.WindCrossVent.GetHashCode();
                if (this.FlowCoefficientClosed != null)
                    hashCode = hashCode * 59 + this.FlowCoefficientClosed.GetHashCode();
                if (this.FlowExponentClosed != null)
                    hashCode = hashCode * 59 + this.FlowExponentClosed.GetHashCode();
                if (this.TwoWayThreshold != null)
                    hashCode = hashCode * 59 + this.TwoWayThreshold.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            foreach(var x in base.BaseValidate(validationContext)) yield return x;

            
            // Type (string) pattern
            Regex regexType = new Regex(@"^VentilationOpening$", RegexOptions.CultureInvariant);
            if (false == regexType.Match(this.Type).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Type, must match a pattern of " + regexType, new [] { "Type" });
            }


            
            // FractionAreaOperable (double) maximum
            if(this.FractionAreaOperable > (double)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FractionAreaOperable, must be a value less than or equal to 1.", new [] { "FractionAreaOperable" });
            }

            // FractionAreaOperable (double) minimum
            if(this.FractionAreaOperable < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FractionAreaOperable, must be a value greater than or equal to 0.", new [] { "FractionAreaOperable" });
            }


            
            // FractionHeightOperable (double) maximum
            if(this.FractionHeightOperable > (double)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FractionHeightOperable, must be a value less than or equal to 1.", new [] { "FractionHeightOperable" });
            }

            // FractionHeightOperable (double) minimum
            if(this.FractionHeightOperable < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FractionHeightOperable, must be a value greater than or equal to 0.", new [] { "FractionHeightOperable" });
            }


            
            // DischargeCoefficient (double) maximum
            if(this.DischargeCoefficient > (double)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DischargeCoefficient, must be a value less than or equal to 1.", new [] { "DischargeCoefficient" });
            }

            // DischargeCoefficient (double) minimum
            if(this.DischargeCoefficient < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DischargeCoefficient, must be a value greater than or equal to 0.", new [] { "DischargeCoefficient" });
            }


            
            // FlowCoefficientClosed (double) minimum
            if(this.FlowCoefficientClosed < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FlowCoefficientClosed, must be a value greater than or equal to 0.", new [] { "FlowCoefficientClosed" });
            }


            
            // FlowExponentClosed (double) maximum
            if(this.FlowExponentClosed > (double)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FlowExponentClosed, must be a value less than or equal to 1.", new [] { "FlowExponentClosed" });
            }

            // FlowExponentClosed (double) minimum
            if(this.FlowExponentClosed < (double)0.5)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FlowExponentClosed, must be a value greater than or equal to 0.5.", new [] { "FlowExponentClosed" });
            }

            yield break;
        }
    }
}
