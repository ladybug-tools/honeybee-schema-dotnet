/* 
 * Honeybee Comparison Report Schema
 *
 * Documentation for Honeybee comparison-report schema
 *
 * Contact: info@ladybug.tools
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

extern alias LBTNewtonSoft; using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using LBTNewtonSoft::Newtonsoft.Json;
using LBTNewtonSoft::Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;


namespace HoneybeeSchema
{
    /// <summary>
    /// ChangedObject
    /// </summary>
    [Summary(@"")]
    [Serializable]
    [DataContract(Name = "ChangedObject")]
    public partial class ChangedObject : OpenAPIGenBaseModel, IEquatable<ChangedObject>, IValidatableObject
    {
        /// <summary>
        /// Text for the type of object that has been changed.
        /// </summary>
        /// <value>Text for the type of object that has been changed.</value>
        [Summary(@"Text for the type of object that has been changed.")]
        [DataMember(Name="element_type")]
        public GeometryObjectTypes ElementType { get; set; }   
        /// <summary>
        /// Initializes a new instance of the <see cref="ChangedObject" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ChangedObject() 
        { 
            // Set non-required readonly properties with defaultValue
            this.Type = "ChangedObject";
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="ChangedObject" /> class.
        /// </summary>
        /// <param name="elementType">Text for the type of object that has been changed. (required).</param>
        /// <param name="elementId">Text string for the unique object ID that has changed. (required).</param>
        /// <param name="geometryChanged">A boolean to note whether the geometry of the object has changed (True) or not (False). For the case of a Room, any change in the geometry of child Faces, Apertures or Doors will cause this property to be True. Note that this property is only True if the change in geometry produces a visible change greater than the base model tolerance. So converting the model between different unit systems, removing colinear vertices, or doing other transformations that are common for export to simulation engines will not trigger this property to become True. (required).</param>
        /// <param name="geometry">A list of DisplayFace3D dictionaries for the new, changed geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. Note that this attribute is always included in the ChangedObject, even when geometry_changed is False. (required).</param>
        /// <param name="elementName">Text string for the display name of the object that has changed..</param>
        /// <param name="energyChanged">A boolean to note whether the energy properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the energy property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed. (default to false).</param>
        /// <param name="radianceChanged">A boolean to note whether the radiance properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the radiance property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed. (default to false).</param>
        /// <param name="existingGeometry">A list of DisplayFace3D dictionaries for the existing (base) geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. This attribute is optional and will NOT be output if geometry_changed is False..</param>
        public ChangedObject
        (
           GeometryObjectTypes elementType, string elementId, bool geometryChanged, List<Object> geometry, // Required parameters
           string elementName= default, bool energyChanged = false, bool radianceChanged = false, List<Object> existingGeometry= default // Optional parameters
        ) : base()// BaseClass
        {
            this.ElementType = elementType;
            // to ensure "elementId" is required (not null)
            this.ElementId = elementId ?? throw new ArgumentNullException("elementId is a required property for ChangedObject and cannot be null");
            this.GeometryChanged = geometryChanged;
            // to ensure "geometry" is required (not null)
            this.Geometry = geometry ?? throw new ArgumentNullException("geometry is a required property for ChangedObject and cannot be null");
            this.ElementName = elementName;
            this.EnergyChanged = energyChanged;
            this.RadianceChanged = radianceChanged;
            this.ExistingGeometry = existingGeometry;

            // Set non-required readonly properties with defaultValue
            this.Type = "ChangedObject";

            // check if object is valid, only check for inherited class
            if (this.GetType() == typeof(ChangedObject))
                this.IsValid(throwException: true);
        }

        //============================================== is ReadOnly 
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [Summary(@"Type")]
        [DataMember(Name = "type")]
        public override string Type { get; protected set; }  = "ChangedObject";

        /// <summary>
        /// Text string for the unique object ID that has changed.
        /// </summary>
        /// <value>Text string for the unique object ID that has changed.</value>
        [Summary(@"Text string for the unique object ID that has changed.")]
        [DataMember(Name = "element_id", IsRequired = true)]
        public string ElementId { get; set; } 
        /// <summary>
        /// A boolean to note whether the geometry of the object has changed (True) or not (False). For the case of a Room, any change in the geometry of child Faces, Apertures or Doors will cause this property to be True. Note that this property is only True if the change in geometry produces a visible change greater than the base model tolerance. So converting the model between different unit systems, removing colinear vertices, or doing other transformations that are common for export to simulation engines will not trigger this property to become True.
        /// </summary>
        /// <value>A boolean to note whether the geometry of the object has changed (True) or not (False). For the case of a Room, any change in the geometry of child Faces, Apertures or Doors will cause this property to be True. Note that this property is only True if the change in geometry produces a visible change greater than the base model tolerance. So converting the model between different unit systems, removing colinear vertices, or doing other transformations that are common for export to simulation engines will not trigger this property to become True.</value>
        [Summary(@"A boolean to note whether the geometry of the object has changed (True) or not (False). For the case of a Room, any change in the geometry of child Faces, Apertures or Doors will cause this property to be True. Note that this property is only True if the change in geometry produces a visible change greater than the base model tolerance. So converting the model between different unit systems, removing colinear vertices, or doing other transformations that are common for export to simulation engines will not trigger this property to become True.")]
        [DataMember(Name = "geometry_changed", IsRequired = true)]
        public bool GeometryChanged { get; set; } 
        /// <summary>
        /// A list of DisplayFace3D dictionaries for the new, changed geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. Note that this attribute is always included in the ChangedObject, even when geometry_changed is False.
        /// </summary>
        /// <value>A list of DisplayFace3D dictionaries for the new, changed geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. Note that this attribute is always included in the ChangedObject, even when geometry_changed is False.</value>
        [Summary(@"A list of DisplayFace3D dictionaries for the new, changed geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. Note that this attribute is always included in the ChangedObject, even when geometry_changed is False.")]
        [DataMember(Name = "geometry", IsRequired = true)]
        public List<Object> Geometry { get; set; } 
        /// <summary>
        /// Text string for the display name of the object that has changed.
        /// </summary>
        /// <value>Text string for the display name of the object that has changed.</value>
        [Summary(@"Text string for the display name of the object that has changed.")]
        [DataMember(Name = "element_name")]
        public string ElementName { get; set; } 
        /// <summary>
        /// A boolean to note whether the energy properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the energy property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed.
        /// </summary>
        /// <value>A boolean to note whether the energy properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the energy property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed.</value>
        [Summary(@"A boolean to note whether the energy properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the energy property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed.")]
        [DataMember(Name = "energy_changed")]
        public bool EnergyChanged { get; set; }  = false;
        /// <summary>
        /// A boolean to note whether the radiance properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the radiance property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed.
        /// </summary>
        /// <value>A boolean to note whether the radiance properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the radiance property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed.</value>
        [Summary(@"A boolean to note whether the radiance properties of the object have changed (True) or not (False) such that it is possible for the properties of the changed object to be applied to the base model. For Rooms, this property will only be true if the radiance property assigned to the Room has changed and will not be true if a property assigned to an individual child Face or Aperture has changed.")]
        [DataMember(Name = "radiance_changed")]
        public bool RadianceChanged { get; set; }  = false;
        /// <summary>
        /// A list of DisplayFace3D dictionaries for the existing (base) geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. This attribute is optional and will NOT be output if geometry_changed is False.
        /// </summary>
        /// <value>A list of DisplayFace3D dictionaries for the existing (base) geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. This attribute is optional and will NOT be output if geometry_changed is False.</value>
        [Summary(@"A list of DisplayFace3D dictionaries for the existing (base) geometry. The schema of DisplayFace3D can be found in the ladybug-display-schema documentation (https://www.ladybug.tools/ladybug-display-schema) and these objects can be used to generate visualizations of individual objects that have been changed. This attribute is optional and will NOT be output if geometry_changed is False.")]
        [DataMember(Name = "existing_geometry")]
        public List<Object> ExistingGeometry { get; set; } 

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            return "ChangedObject";
        }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString(bool detailed)
        {
            if (!detailed)
                return this.ToString();
            
            var sb = new StringBuilder();
            sb.Append("ChangedObject:\n");
            sb.Append("  Type: ").Append(this.Type).Append("\n");
            sb.Append("  ElementType: ").Append(this.ElementType).Append("\n");
            sb.Append("  ElementId: ").Append(this.ElementId).Append("\n");
            sb.Append("  GeometryChanged: ").Append(this.GeometryChanged).Append("\n");
            sb.Append("  Geometry: ").Append(this.Geometry).Append("\n");
            sb.Append("  ElementName: ").Append(this.ElementName).Append("\n");
            sb.Append("  EnergyChanged: ").Append(this.EnergyChanged).Append("\n");
            sb.Append("  RadianceChanged: ").Append(this.RadianceChanged).Append("\n");
            sb.Append("  ExistingGeometry: ").Append(this.ExistingGeometry).Append("\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the object from JSON string
        /// </summary>
        /// <returns>ChangedObject object</returns>
        public static ChangedObject FromJson(string json)
        {
            var obj = JsonConvert.DeserializeObject<ChangedObject>(json, JsonSetting.AnyOfConvertSetting);
            if (obj == null)
                return null;
            return obj.Type.ToLower() == obj.GetType().Name.ToLower() && obj.IsValid(throwException: true) ? obj : null;
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>ChangedObject object</returns>
        public virtual ChangedObject DuplicateChangedObject()
        {
            return FromJson(this.ToJson());
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel Duplicate()
        {
            return DuplicateChangedObject();
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel DuplicateOpenAPIGenBaseModel()
        {
            return DuplicateChangedObject();
        }
     
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            input = input is AnyOf anyOf ? anyOf.Obj : input;
            return this.Equals(input as ChangedObject);
        }

        /// <summary>
        /// Returns true if ChangedObject instances are equal
        /// </summary>
        /// <param name="input">Instance of ChangedObject to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ChangedObject input)
        {
            if (input == null)
                return false;
            return base.Equals(input) && 
                    Extension.Equals(this.ElementType, input.ElementType) && 
                    Extension.Equals(this.ElementId, input.ElementId) && 
                    Extension.Equals(this.GeometryChanged, input.GeometryChanged) && 
                (
                    this.Geometry == input.Geometry ||
                    Extension.AllEquals(this.Geometry, input.Geometry)
                ) && 
                    Extension.Equals(this.ElementName, input.ElementName) && 
                    Extension.Equals(this.EnergyChanged, input.EnergyChanged) && 
                    Extension.Equals(this.RadianceChanged, input.RadianceChanged) && 
                (
                    this.ExistingGeometry == input.ExistingGeometry ||
                    Extension.AllEquals(this.ExistingGeometry, input.ExistingGeometry)
                ) && 
                    Extension.Equals(this.Type, input.Type);
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.ElementType != null)
                    hashCode = hashCode * 59 + this.ElementType.GetHashCode();
                if (this.ElementId != null)
                    hashCode = hashCode * 59 + this.ElementId.GetHashCode();
                if (this.GeometryChanged != null)
                    hashCode = hashCode * 59 + this.GeometryChanged.GetHashCode();
                if (this.Geometry != null)
                    hashCode = hashCode * 59 + this.Geometry.GetHashCode();
                if (this.ElementName != null)
                    hashCode = hashCode * 59 + this.ElementName.GetHashCode();
                if (this.EnergyChanged != null)
                    hashCode = hashCode * 59 + this.EnergyChanged.GetHashCode();
                if (this.RadianceChanged != null)
                    hashCode = hashCode * 59 + this.RadianceChanged.GetHashCode();
                if (this.ExistingGeometry != null)
                    hashCode = hashCode * 59 + this.ExistingGeometry.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            foreach(var x in base.BaseValidate(validationContext)) yield return x;
            // ElementId (string) maxLength
            if(this.ElementId != null && this.ElementId.Length > 100)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ElementId, length must be less than 100.", new [] { "ElementId" });
            }

            // ElementId (string) minLength
            if(this.ElementId != null && this.ElementId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ElementId, length must be greater than 1.", new [] { "ElementId" });
            }
            
            // ElementId (string) pattern
            Regex regexElementId = new Regex(@"^[^,;!\n\t]+$", RegexOptions.CultureInvariant);
            if (this.ElementId != null && false == regexElementId.Match(this.ElementId).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ElementId, must match a pattern of " + regexElementId, new [] { "ElementId" });
            }


            
            // Type (string) pattern
            Regex regexType = new Regex(@"^ChangedObject$", RegexOptions.CultureInvariant);
            if (this.Type != null && false == regexType.Match(this.Type).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Type, must match a pattern of " + regexType, new [] { "Type" });
            }

            yield break;
        }
    }
}
